# -*- coding: utf-8 -*-
"""Tours_seduling (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1doM19eCNmWbmf4DzOf3TGhPBnpyhgbJe
"""

!pip install pulp

import pandas as pd
from datetime import datetime, timedelta
from pulp import LpMinimize, LpProblem, LpVariable, lpSum
import string
from datetime import datetime, timedelta
import datetime

flight_schedule = pd.read_excel("flights_schedule.xlsx")  # Read Excel file
aircraft_type = pd.read_excel("Aircraft_type.xlsx")
airport_code = pd.read_excel("Airport_code.xlsx")
salary = pd.read_excel("salary.xlsx")

flight_schedule

aircraft_type

airport_code

# Add IATA codes to the Flights DataFrame
flight_schedule = flight_schedule.merge(airport_code.rename(columns={'City': 'From', 'IATA airport code': 'From_IATA'}),
                        on='From', how='left')

flight_schedule = flight_schedule.merge(airport_code.rename(columns={'City': 'To', 'IATA airport code': 'To_IATA'}),
                        on='To', how='left')

flight_schedule

# Merge the dataframes on Aircraft Type
flight_schedule = flight_schedule.merge(aircraft_type, left_on="Aircraft_Type", right_on="aircraft_type", how="left")

# Drop the redundant aircraft_type column
flight_schedule.drop(columns=["aircraft_type"], inplace=True)

flight_schedule.head()

# Convert times to datetime, but keep only time (remove the date part)
flight_schedule['Start_time(SLST)'] = pd.to_datetime(flight_schedule['Start_time(SLST)'], format='%H:%M:%S').dt.strftime('%H:%M:%S')
flight_schedule['Arrival_time(SLST)'] = pd.to_datetime(flight_schedule['Arrival_time(SLST)'], format='%H:%M:%S').dt.strftime('%H:%M:%S')

# Function to calculate duration in hours (as a decimal)
def calculate_duration(row):
    start_time = pd.to_datetime(row['Start_time(SLST)'], format='%H:%M:%S')
    arrival_time = pd.to_datetime(row['Arrival_time(SLST)'], format='%H:%M:%S')

    if arrival_time > start_time:
        duration = arrival_time - start_time
    else:
        # If arrival is the next day
        arrival_time += pd.Timedelta(hours=24)
        duration = arrival_time - start_time

    hours = duration.seconds // 3600
    minutes = (duration.seconds % 3600) // 60
    # Convert minutes to decimal and add to hours
    decimal_hours = hours + minutes / 60
    return round(decimal_hours, 2)

# Apply the function to calculate the duration for each flight
flight_schedule['Duration_hours'] = flight_schedule.apply(calculate_duration, axis=1)
flight_schedule.head()

# Transforming data into a single table with a 'Day' column
all_flights = []
for day in ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]:
    temp_df = flight_schedule[flight_schedule[day] == 1][["ID", "From","From_IATA", "To","To_IATA","Start_time(SLST)", "Arrival_time(SLST)","Min", "Max", "Duration_hours"]].copy()
    temp_df.insert(0, "Start_Day", day)  # Insert 'Day' column at the beginning
    all_flights.append(temp_df)

final_df = pd.concat(all_flights, ignore_index=True)
# final_df


# # Save the final schedule to a new Excel file
# output_file = "grouped_flights.xlsx"
# final_df.to_excel(output_file, index=False)

# Displaying the final schedule
# print(final_df.to_string(index=False))
final_df

"""Get the end day"""

# Convert 'start time(SLST)' to a datetime object for proper sorting
final_df["Start_time(SLST)"] = pd.to_datetime(final_df["Start_time(SLST)"], format="%H:%M:%S").dt.time

# Define a custom sorting order for days of the week
day_order = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]

# Sort by the custom day order first, then by 'start time(SLST)'
final_df["Start_Day"] = pd.Categorical(final_df["Start_Day"], categories=day_order, ordered=True)
final_df = final_df.sort_values(by=["Start_Day", "Start_time(SLST)"]).reset_index(drop=True)

# Display the sorted dataframe
# final_df

from datetime import datetime, timedelta

# Assume all the flights end in 2 days
travel_duration = final_df['Duration_hours'].tolist()  # Convert to list if it's a pandas Series
# travel_start_time = [datetime.strptime(time, "%H:%M:%S") for time in final_df['Start_time(SLST)']]  # Create list of start times
# Create a reference date (you can use any date)
reference_date = datetime(2000, 1, 1)

# Create list of start times as datetime objects
travel_start_time = [datetime.combine(reference_date, time) for time in final_df['Start_time(SLST)']]

travel_endtime_duration_variable = []
time_to_add = []

for i in range(len(final_df)):
    time_to_add.append(timedelta(hours=travel_duration[i]))  # Append timedelta to the list
    new_time = travel_start_time[i] + time_to_add[i]

    # Check if the new time crosses into the next day (or days)
    if new_time.hour < travel_start_time[i].hour:  # This checks if the new time has rolled over past midnight
        travel_endtime_duration_variable.append(1)
    else:
        travel_endtime_duration_variable.append(0)

# Define a custom sorting order for days of the week
day_order = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]

index = []
for i in range(len(final_df)):
  travel_start_day=final_df['Start_Day'][i];
  if travel_start_day in day_order:
     index.append(day_order.index(travel_start_day))
  else:
      index.append(-1)  # or handle the case where travel_start_day is not in day_order

travel_end_day_index=[]
for i in range(len(final_df)):
  travel_end_day_index.append(travel_endtime_duration_variable[i] + index[i])
  if  travel_end_day_index[i] > 6:
    travel_end_day_index[i] = travel_end_day_index[i] - 7

End_days = [day_order[index] for index in travel_end_day_index]
final_df['End_Day'] = End_days

final_2 = final_df.copy(deep=True)
final_3 = final_df.copy(deep=True)

final_df

# Assign Allocated_Members dynamically without storing Day_Frequency - Flight 1
final_df["Allocated_Members_Flight_1"] = final_df["Start_Day"].str[0:2] + "/" + final_df["From_IATA"].str[0:3] + "/"+ final_df["ID"].str[-3:] + "/"+ final_df["To_IATA"].str[0:3]
final_df

unique_count =final_df["Allocated_Members_Flight_1"].nunique()

unique_count

# Assign Allocated_Members dynamically without storing Day_Frequency - Flight 1
# final_df["Allocated_Members_Flight_1"] =final_df["From_IATA"].str[0:3] + "_" + final_df["To_IATA"].str[0:3] +  "_" + final_df["Start_Day"].str[0:2] + (final_df.groupby("Start_Day").cumcount() + 1).astype(str)
# final_df

Flight_1_df = final_df

Flight_1_df.columns = ["Flight_1_Start_Day", "Flight_1_ID", "Flight_1_From", "Flight_1_From_IATA", "Flight_1_To","Flight_1_To_IATA", "Flight_1_start_time(SLST)", "Flight_1_Arrival_time(SLST)", "Flight_1_Min",	"Flight_1_Max", "Flight_1_duration_hours", "Flight_1_End_Day", "Flight_1_Allocated_Members"]

Flight_1_df.head()

Flight_2_df = final_2

Flight_2_df.columns=["Flight_2_Start_Day", "Flight_2_ID", "Flight_2_From","Flight_2_From_IATA", "Flight_2_To", "Flight_2_To_IATA", "Flight_2_start_time(SLST)", "Flight_2_Arrival_time(SLST)", "Flight_2_Min",	"Flight_2_Max","Flight_2_duration_hours" , "Flight_2_End_Day"]

# Perform the join
combined_flights_1 = pd.merge(Flight_1_df, Flight_2_df, left_on='Flight_1_To', right_on='Flight_2_From')

# Display the result
combined_flights_1

combined_flights_1.to_csv("combined_flights_1.csv", index=False)

combined_flights_1.shape

import datetime
import pandas as pd

# Function to convert day names (e.g., "Monday") into future dates
def get_date_from_day(day_name, reference_date):
    weekdays = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]

    if day_name not in weekdays:
        return None

    ref_index = reference_date.weekday()
    day_index = weekdays.index(day_name)

    days_ahead = (day_index - ref_index + 7) % 7
    if days_ahead == 0:
        days_ahead = 7


    return reference_date + datetime.timedelta(days=days_ahead)

# Load dataset
combination_1 = combined_flights_1

# Reference date (today)
reference_date = pd.Timestamp.now().date()

reference_date

combination_1['Flight 1 Start Date'] = combination_1['Flight_1_Start_Day'].apply(
    lambda day: get_date_from_day(day, reference_date)
)

combination_1['Flight 1 End Date'] = combination_1['Flight_1_End_Day'].apply(
    lambda day: get_date_from_day(day, reference_date)
)

combination_1['Flight 1 End Date'] = combination_1.apply(
    lambda row: row['Flight 1 Start Date'] if row['Flight_1_Start_Day'] == row['Flight_1_End_Day'] else row['Flight 1 End Date'],
    axis=1
)

import numpy as np
import pandas as pd

# Convert day names to numbers
day_mapping = {
    "Monday": 0, "Tuesday": 1, "Wednesday": 2, "Thursday": 3,
    "Friday": 4, "Saturday": 5, "Sunday": 6
}

combination_1['Flight_1_End_Day_Num'] = combination_1['Flight_1_End_Day'].map(day_mapping)
combination_1['Flight_2_Start_Day_Num'] = combination_1['Flight_2_Start_Day'].map(day_mapping)
combination_1['Flight_2_End_Day_Num'] = combination_1['Flight_2_End_Day'].map(day_mapping)

combination_1['Flight 1 Start Date'] = pd.to_datetime(combination_1['Flight 1 Start Date'])
combination_1['Flight 1 End Date'] = pd.to_datetime(combination_1['Flight 1 End Date'])

# # Flight 2 Start Date
# Convert 'Flight 1 End Date' to datetime
combination_1['Flight 1 End Date'] = pd.to_datetime(combination_1['Flight 1 End Date'])

# Ensure it is not categorical
if pd.api.types.is_categorical_dtype(combination_1['Flight 1 End Date']):
    combination_1['Flight 1 End Date'] = combination_1['Flight 1 End Date'].astype('datetime64[ns]')

# Convert to integer if needed
combination_1['Flight_2_Start_Day_Num'] = pd.to_numeric(combination_1['Flight_2_Start_Day_Num'], errors='coerce')

# Get the weekday of Flight 1 End Date (Monday=0, ..., Sunday=6)
combination_1['Flight_1_End_Day_Num'] = combination_1['Flight 1 End Date'].dt.weekday

# Define mask: True if Start Day Num is after or on the same day as End Day Num
mask = combination_1['Flight_2_Start_Day_Num'] >= combination_1['Flight_1_End_Day_Num']

# Case 1: Flight 2 Start is in the same week
combination_1.loc[mask, 'Flight 2 Start Date'] = (
    combination_1['Flight 1 End Date'] +
    pd.to_timedelta(combination_1['Flight_2_Start_Day_Num'] - combination_1['Flight_1_End_Day_Num'], unit='D')
)

# Case 2: Flight 2 Start is in the next week (~mask)
combination_1.loc[~mask, 'Flight 2 Start Date'] = (
    combination_1['Flight 1 End Date'] +
    pd.to_timedelta(7 - (combination_1['Flight_1_End_Day_Num'] - combination_1['Flight_2_Start_Day_Num']), unit='D')
)

# # Flight 2 End Date
# Convert column to datetime
combination_1['Flight 2 Start Date'] = pd.to_datetime(combination_1['Flight 2 Start Date'])

# Ensure it is not categorical
if pd.api.types.is_categorical_dtype(combination_1['Flight 2 Start Date']):
    combination_1['Flight 2 Start Date'] = combination_1['Flight 2 Start Date'].astype('datetime64[ns]')


mask2 = combination_1['Flight_2_End_Day_Num'] >= combination_1['Flight_2_Start_Day_Num']

# Case 1: Flight 2 End is in the same week
combination_1.loc[mask2, 'Flight 2 End Date'] = (
    combination_1['Flight 2 Start Date'] +
    pd.to_timedelta(combination_1['Flight_2_End_Day_Num'] - combination_1['Flight_2_Start_Day_Num'], unit='D')
)

# Case 2: Flight 2 End is in the next week (~mask)
combination_1.loc[~mask2, 'Flight 2 End Date'] = (
    combination_1['Flight 2 Start Date'] +
    pd.to_timedelta(7 - (combination_1['Flight_2_Start_Day_Num'] - combination_1['Flight_2_End_Day_Num']), unit='D')
)

# import datetime
# import pandas as pd

# # Function to convert day names (e.g., "Monday") into future dates
# def get_date_from_day(day_name, reference_date):
#     weekdays = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]

#     if day_name not in weekdays:
#         return None

#     ref_index = reference_date.weekday()
#     day_index = weekdays.index(day_name)

#     days_ahead = (day_index - ref_index + 7) % 7
#     if days_ahead == 0:
#         days_ahead = 7

#     return reference_date + datetime.timedelta(days=days_ahead)

# # Load dataset
# combination_1 = combined_flights_1

# # Reference date (today)
# reference_date = datetime.date.today()

# # --- Flight 1 Start and End Dates ---
# combination_1['Flight 1 Start Date'] = combination_1['Flight_1_Start_Day'].apply(get_date_from_day, reference_date=reference_date)
# combination_1['Flight 1 End Date'] = combination_1['Flight_1_End_Day'].apply(get_date_from_day, reference_date=reference_date)

# # Convert to datetime (fix categorical issue)
# combination_1['Flight 1 Start Date'] = pd.to_datetime(combination_1['Flight 1 Start Date'])
# combination_1['Flight 1 End Date'] = pd.to_datetime(combination_1['Flight 1 End Date'])

# # Ensure Flight 1 End Date is after Start Date
# combination_1.loc[combination_1['Flight 1 End Date'] < combination_1['Flight 1 Start Date'], 'Flight 1 End Date'] += pd.Timedelta(days=7)

# # --- Flight 2 Start and End Dates ---
# combination_1['Flight 2 Start Date'] = combination_1['Flight_2_Start_Day'].apply(get_date_from_day, reference_date=reference_date)
# combination_1['Flight 2 End Date'] = combination_1['Flight_2_End_Day'].apply(get_date_from_day, reference_date=reference_date)

# # Convert to datetime (fix categorical issue)
# combination_1['Flight 2 Start Date'] = pd.to_datetime(combination_1['Flight 2 Start Date'])
# combination_1['Flight 2 End Date'] = pd.to_datetime(combination_1['Flight 2 End Date'])

# # Ensure Flight 2 Start Date is after Flight 1 End Date
# combination_1.loc[combination_1['Flight 2 Start Date'] <= combination_1['Flight 1 End Date'], 'Flight 2 Start Date'] = combination_1['Flight 1 End Date'] + pd.Timedelta(days=1)

# # Ensure Flight 2 End Date is after Flight 2 Start Date
# combination_1.loc[combination_1['Flight 2 End Date'] < combination_1['Flight 2 Start Date'], 'Flight 2 End Date'] += pd.Timedelta(days=7)

# # --- Flight 3 Start and End Dates ---
# combination_1['Flight 3 Start Date'] = combination_1['Flight_3_Start_Day'].apply(get_date_from_day, reference_date=reference_date)
# combination_1['Flight 3 End Date'] = combination_1['Flight_3_End_Day'].apply(get_date_from_day, reference_date=reference_date)

# # Convert to datetime (fix categorical issue)
# combination_1['Flight 3 Start Date'] = pd.to_datetime(combination_1['Flight 3 Start Date'])
# combination_1['Flight 3 End Date'] = pd.to_datetime(combination_1['Flight 3 End Date'])

# # Ensure Flight 3 Start Date is after both Flight 1 and Flight 2 End Dates
# combination_1['Flight 3 Start Date'] = combination_1[['Flight 1 End Date', 'Flight 2 End Date']].max(axis=1) + pd.Timedelta(days=1)

# # Ensure Flight 3 End Date is after Flight 3 Start Date
# combination_1.loc[combination_1['Flight 3 End Date'] < combination_1['Flight 3 Start Date'], 'Flight 3 End Date'] += pd.Timedelta(days=7)

# # Start the first tour accounding to the first day that according to the today date
# combination_1['Flight 1 Start Date'] = combination_1['Flight_1_Start_Day'].apply(get_date_from_day, reference_date=datetime.date.today())
# if(combination_1['Flight_1_Start_Day'] == combination_1['Flight_1_End_Day']).all():
#     combination_1['Flight 1 End Date'] = combination_1['Flight 1 Start Date']
# else:
#   combination_1['Flight 1 End Date'] = combination_1['Flight_1_End_Day'].apply(get_date_from_day, reference_date=datetime.date.today())

# combination_1['Flight 1 End Date'] = combination_1['Flight_1_End_Day'].apply(get_date_from_day, reference_date=datetime.date.today())

# if (combination_1['Flight_1_End_Day'] == combination_1['Flight_2_Start_Day']).all():
#     combination_1['Flight 2 Start Date'] = combination_1['Flight 1 End Date']
# else:
#   combination_1['Flight 2 Start Date'] = combination_1['Flight_2_Start_Day'].apply(get_date_from_day, reference_date=datetime.date.today())


# Convert time columns to proper time format
combination_1['Flight_1_Arrival_time(SLST)'] = pd.to_datetime(
    combination_1['Flight_1_Arrival_time(SLST)'], format="%H:%M:%S", errors='coerce'
).dt.time

combination_1['Flight_2_start_time(SLST)'] = pd.to_datetime(
    combination_1['Flight_2_start_time(SLST)'], format="%H:%M:%S", errors='coerce'
).dt.time

# combination_1_new = combination_1.copy()

# Convert to string before concatenation
combination_1['Flight 1 End Date'] = combination_1['Flight 1 End Date'].astype(str)
combination_1['Flight_1_Arrival_time(SLST)'] = combination_1['Flight_1_Arrival_time(SLST)'].astype(str)

# Create Flight 1 Arrival datetime
combination_1['Flight 1 Arrival datetime'] = combination_1['Flight 1 End Date'] + ' ' + combination_1['Flight_1_Arrival_time(SLST)']
combination_1['Flight 1 Arrival datetime'] = pd.to_datetime(combination_1['Flight 1 Arrival datetime'])

# Ensure both columns are in string format for Flight 2 start datetime
combination_1['Flight 2 Start Date'] = combination_1['Flight 2 Start Date'].astype(str)
combination_1['Flight_2_start_time(SLST)'] = combination_1['Flight_2_start_time(SLST)'].astype(str)

# Combine date and time columns for Flight 2
combination_1['Flight 2 start datetime'] = combination_1['Flight 2 Start Date'] + ' ' + combination_1['Flight_2_start_time(SLST)']
combination_1['Flight 2 start datetime'] = pd.to_datetime(combination_1['Flight 2 start datetime'])
combination_1.to_csv("combination_1_new.csv", index = False)

# combination_1['Flight 2 start datetime']=combination_1_new['Flight 2 start datetime']
# combination_1['Flight 1 Arrival datetime']=combination_1_new['Flight 1 Arrival datetime']

# # Function to combine date and time into full datetime
# def convert_to_datetime(date, time_value):
#     if pd.isna(date) or pd.isna(time_value):
#         return None
#     return datetime.datetime.combine(date, time_value)

# # Apply conversion
# combination_1['Flight 1 Arrival datetime'] = combination_1.apply(
#     lambda row: convert_to_datetime(row['Flight 1 End Date'], row['Flight_1_Arrival_time(SLST)']), axis=1
# )
# combination_1['Flight 2 start datetime'] = combination_1.apply(
#     lambda row: convert_to_datetime(row['Flight 2 Start Date'], row['Flight_2_start_time(SLST)']), axis=1
# )

filtered_flights = combination_1[
    (
        # Case where the dates are the same
        (
            (combination_1['Flight 2 Start Date'].astype('datetime64[ns]') == combination_1['Flight 1 End Date'].astype('datetime64[ns]')) &
            (combination_1['Flight 1 Arrival datetime'].astype('datetime64[ns]') < combination_1['Flight 2 start datetime'].astype('datetime64[ns]'))
        )
        |
        # Case where the dates are different
        (
            (combination_1['Flight 2 Start Date'].astype('datetime64[ns]') > combination_1['Flight 1 End Date'].astype('datetime64[ns]')) &  # Allow same day
            (combination_1['Flight 2 Start Date'].astype('datetime64[ns]') < (combination_1['Flight 1 End Date'].astype('datetime64[ns]') + pd.Timedelta(days=7))) &  # Less than 7 days apart
            (combination_1['Flight 1 Arrival datetime'].astype('datetime64[ns]') < combination_1['Flight 2 Start Date'].astype('datetime64[ns]'))  # Flight 1 arrives before Flight 2 starts
        )
    )
]

filtered_flights.shape

filtered_flights.to_csv("filtered_flights.csv", index=False)

# Condition 1: Check for invalid cases where Flight 1 arrival time is greater than Flight 2 start time
invalid_flights = filtered_flights[
    (filtered_flights['Flight 1 End Date'] == filtered_flights['Flight 2 Start Date']) &  # Same day
    (filtered_flights['Flight 1 Arrival datetime'] >= filtered_flights['Flight 2 start datetime'])  # Invalid condition
]

if not invalid_flights.empty:
    print("Invalid flight entries detected where Flight 1 arrival is after or at Flight 2 start time:")
    print(invalid_flights[['Flight 1 Arrival datetime', 'Flight 2 start datetime']])

# Drop invalid flights from the main DataFrame
filtered_flights = filtered_flights[~filtered_flights.index.isin(invalid_flights.index)]
# Optionally, reset the index if desired
filtered_flights.reset_index(drop=True, inplace=True)

filtered_flights.shape

# Condition 2: Ensure Flight 1 End Date < Flight 2 Start Date
invalid_flights_condition_2 = filtered_flights[
    filtered_flights['Flight 1 End Date'].astype('datetime64[ns]') > (filtered_flights['Flight 2 Start Date'].astype('datetime64[ns]'))
]

if not invalid_flights_condition_2.empty:
    print("Flight 1 End Date < Flight 2 Start Date:")
    print(invalid_flights_condition_2[[ 'Flight 1 End Date', 'Flight 2 Start Date']])

# Drop invalid flights from the main DataFrame
filtered_flights = filtered_flights[~filtered_flights.index.isin(invalid_flights_condition_2.index)]
# Optionally, reset the index if desired
filtered_flights.reset_index(drop=True, inplace=True)

# Calculate waiting time
filtered_flights['Waiting Time'] = filtered_flights['Flight 2 start datetime'] - filtered_flights['Flight 1 Arrival datetime']

# Convert waiting time to hours for better readability
filtered_flights['Waiting Time (hours)'] = filtered_flights['Waiting Time'].dt.total_seconds() / 3600

# Apply filtering condition: Keep all rows, but filter when Flight 1 Day == Flight 2 Day
filtered_flights_1 = filtered_flights[
    (filtered_flights['Flight 1 End Date'] != filtered_flights['Flight 2 Start Date']) |  # Keep data where days are different
    (filtered_flights['Flight 1 Arrival datetime'] < filtered_flights['Flight 2 start datetime'])  # Apply condition when days match
]

# Display or save the filtered DataFrame
# filtered_flights.to_csv("filtered_flights.csv", index=False)
filtered_flights_1[[ 'Flight 1 Arrival datetime', 'Flight 2 start datetime', 'Waiting Time (hours)']]
# # Save the filtered results to CSV
# filtered_flights_1.to_csv("filtered_flights_1.csv", index=False)

# Function to calculate waiting days based on waiting time in hours
def calculate_waiting_days(waiting_time):
    waiting_days = 0
    thresholds = [24, 48, 72, 96, 120, 144, 168]  # Define thresholds in hours

    for threshold in thresholds:
        if waiting_time < threshold:
            break  # Stop if the waiting time is less than the threshold
        waiting_days += 1  # Increment waiting days for each threshold exceeded

    return waiting_days

# Assuming 'Waiting Time' is already in hours in the filtered_flights_1 DataFrame
filtered_flights_1['Waiting Days'] = filtered_flights_1['Waiting Time (hours)'].apply(calculate_waiting_days)

# Drop unnecessary columns (ignoring errors if they don't exist)
filtered_flights_1.drop(columns=['Flight 1 Date', 'Flight 2 Date', 'Flight 1 Arrival datetime', 'Flight 2 start datetime', 'Waiting Time', 'Waiting Time (minutes)','Flight_1_End_Day_Num', 'Flight_2_Start_Day_Num', 'Flight_2_End_Day_Num'], inplace=True, errors='ignore')
# filtered_flights_1["1st_tour_total_flight_hours"] = filtered_flights_1["Flight_1_duration_hours"] + filtered_flights_1["Flight_2_duration_hours"]
# Display or save the updated DataFrame as needed
# filtered_flights_1.to_csv("filtered_flights_1.csv", index=False)

print("Filtered flights with waiting time and waiting days saved successfully!")

filtered_flights_1.columns

# # Assign Allocated_Members dynamically without storing Day_Frequency - Flight 2
filtered_flights_1["Flight_2_Allocated_Members"] = filtered_flights_1["Flight_1_Allocated_Members"].str[:] + "_" + filtered_flights_1["Flight_2_Start_Day"].str[0:2] +"/"+ filtered_flights_1["Flight_2_From_IATA"].str[0:3] + "/" +  filtered_flights_1["Flight_2_ID"].str[-3:] + "/" + filtered_flights_1["Flight_2_To_IATA"].str[0:3]
# final_df

# # Assign Allocated_Members dynamically without storing Day_Frequency - Flight 2
# filtered_flights_1["Flight_2_Allocated_Members"] = filtered_flights_1["Flight_1_Allocated_Members"].str[0:7] + "_" + filtered_flights_1["Flight_2_To_IATA"].str[0:3] + "_" + filtered_flights_1["Flight_1_Allocated_Members"].str[8:11] + (filtered_flights_1.groupby("Flight_1_Allocated_Members").cumcount() + 1).astype(str)
# # final_df

filtered_flights_1["Flight_2_Allocated_Members"]

unique_count =filtered_flights_1["Flight_2_Allocated_Members"].nunique()

unique_count

filtered_flights_1.to_csv("filtered_flights_1.csv", index=False)

# # Count occurrences for 'Flight 1 Allocated_Members'
# counts = filtered_flights_1.groupby("Flight_1_Allocated_Members").cumcount() + 1
# print(counts[9])
# # Convert numbers > 9 to letters (A=10, B=11, C=12, ...)
# def num_to_label(n):
#     return str(n) if n <= 9 else string.ascii_uppercase[n - 10]  # Convert 10 → A, 11 → B, etc.

# # Apply transformation
# filtered_flights_1["Flight_2_Allocated_Members"] = (
#     filtered_flights_1["Flight_2_Allocated_Members"].str[:15] + counts.apply(num_to_label)
# )

# filtered_flights_1.to_csv("filtered_flights_1.csv", index=False)

# # Assign Allocated_Members dynamically without storing Day_Frequency - Flight 2
# filtered_flights_1["Flight_2_Allocated_Members"] = filtered_flights_1["Flight_1_Allocated_Members"].str[0] + filtered_flights_1["Flight_1_Allocated_Members"].str[1] + filtered_flights_1["Flight_1_Allocated_Members"].str[2] + (filtered_flights_1.groupby("Flight_1_Allocated_Members").cumcount() + 1).astype(str)

# filtered_flights_1

# filtered_flights_1.to_csv("filtered_flights_1.csv", index=False)

# Define a function to check the condition
def set_tour_type(row):
    if row["Flight_1_From"] == row["Flight_2_To"]:
        return "Return Double Tours (P*2)"
    else:
        return "No Return Double Tours (P3)"

# Apply the function to create the new column
filtered_flights_1["Tour Type"] = filtered_flights_1.apply(set_tour_type, axis=1)

# Move "Tour Type" to the first column
filtered_flights_1.insert(0, "Tour Type", filtered_flights_1.pop("Tour Type"))

# Verify the change
# filtered_flights_1 # Display first few rows to check

# Separate DataFrames based on Tour Type and reset index
df_return_double = filtered_flights_1[filtered_flights_1["Tour Type"] == "Return Double Tours (P*2)"].reset_index(drop=True)
df_no_return_double = filtered_flights_1[filtered_flights_1["Tour Type"] == "No Return Double Tours (P3)"].reset_index(drop=True)

# Display the shapes of the new DataFrames
print("Return Double Tours:", df_return_double.shape)
print("No Return Double Tours:", df_no_return_double.shape)

filtered_flights_1.columns

# Select only the relevant columns
df_selected = filtered_flights_1[['Flight_1_Allocated_Members','Flight 1 Start Date', 'Flight_1_start_time(SLST)', 'Flight 1 End Date', 'Flight_1_Arrival_time(SLST)']]
# Drop duplicates based on column1
result_1 = df_selected.drop_duplicates(subset='Flight_1_Allocated_Members')

# Convert Flight 1 Start Date to datetime
result_1['Flight 1 Start Date'] = pd.to_datetime(result_1['Flight 1 Start Date'])

# Sort by Flight 1 Start Date (now as date)
result_sorted = result_1.sort_values(by='Flight 1 Start Date')
# Save to CSV
result_sorted.to_csv('unique_column1_for_flight1_crew.csv', index=False)

result_1



filtered_flights_1.to_csv("filtered_flights_1.csv", index=False)

df_no_return_double.to_csv("No_return_double.csv", index=False)

df_return_double.to_csv("Return_double.csv", index=False)

df_no_return_double_new = df_no_return_double.drop(columns=["Tour Type"])

df_no_return_double_new.shape

filtered_flights_1.columns

# Separate flights into 1st and 2nd flight categories
# df_no_return_2 = no return double tours drop the type of tour column
df_no_return_2 = df_no_return_double_new[df_no_return_double["Flight_2_Start_Day"].isin(["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"])] # First flights are sorted by day and start time
Flight_3_df = final_3[final_3["Start_Day"].isin(["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"])] # Second flights are sorted by arrival time

Flight_3_df.columns=["Flight_3_Start_Day", "Flight_3_ID", "Flight_3_From","Flight_3_From_IATA", "Flight_3_To","Flight_3_To_IATA", "Flight_3_start_time(SLST)", "Flight_3_Arrival_time(SLST)", "Flight_3_Min",	"Flight_3_Max","Flight_3_duration_hours" , "Flight_3_End_Day"]

# Perform the join
combined_flights_2 = pd.merge(df_no_return_2, Flight_3_df, left_on='Flight_2_To', right_on='Flight_3_From')

# Display the result
combined_flights_2

combined_flights_2.shape

combined_flights_2 = combined_flights_2[combined_flights_2['Flight_1_To'] != combined_flights_2['Flight_3_To']]

combined_flights_2.to_csv("combined_flights_2.csv", index=False)

combined_flights_2.shape

combined_flights_2.columns

# # --- Flight 3 Start and End Dates ---
# combination_2['Flight 3 Start Date'] = combination_2['Flight_3_Start_Day'].apply(get_date_from_day, reference_date=reference_date)
# combination_2['Flight 3 End Date'] = combination_1['Flight_3_End_Day'].apply(get_date_from_day, reference_date=reference_date)

# # Convert to datetime (fix categorical issue)
# combination_2['Flight 3 Start Date'] = pd.to_datetime(combination_1['Flight 3 Start Date'])
# combination_1['Flight 3 End Date'] = pd.to_datetime(combination_1['Flight 3 End Date'])

# # Ensure Flight 3 Start Date is after both Flight 1 and Flight 2 End Dates
# combination_1['Flight 3 Start Date'] = combination_1[['Flight 1 End Date', 'Flight 2 End Date']].max(axis=1) + pd.Timedelta(days=1)

# # Ensure Flight 3 End Date is after Flight 3 Start Date
# combination_1.loc[combination_1['Flight 3 End Date'] < combination_1['Flight 3 Start Date'], 'Flight 3 End Date'] += pd.Timedelta(days=7)

import datetime
import pandas as pd

# Function to convert day names (e.g., "Monday") into future dates
def get_date_from_day(day_name, reference_date):
    weekdays = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]

    if day_name not in weekdays:
        return None

    ref_index = reference_date.weekday()
    day_index = weekdays.index(day_name)

    days_ahead = (day_index - ref_index + 7) % 7
    if days_ahead == 0:
        days_ahead = 7

    return reference_date + datetime.timedelta(days=days_ahead)

# Load dataset
combination_2 = pd.DataFrame(combined_flights_2)

import numpy as np
import pandas as pd

# Convert day names to numbers
day_mapping = {
    "Monday": 0, "Tuesday": 1, "Wednesday": 2, "Thursday": 3,
    "Friday": 4, "Saturday": 5, "Sunday": 6
}

combination_2['Flight_3_End_Day_Num'] = combination_2['Flight_3_End_Day'].map(day_mapping)
combination_2['Flight_3_Start_Day_Num'] = combination_2['Flight_3_Start_Day'].map(day_mapping)
combination_2['Flight_2_Start_Day_Num'] = combination_2['Flight_2_Start_Day'].map(day_mapping)
combination_2['Flight_2_End_Day_Num'] = combination_2['Flight_2_End_Day'].map(day_mapping)

combination_2['Flight 2 Start Date'] = pd.to_datetime(combination_2['Flight 2 Start Date'])
combination_2['Flight 2 End Date'] = pd.to_datetime(combination_2['Flight 2 End Date'])

# # Flight 3 Start Date
# Convert 'Flight 2 End Date' to datetime
combination_2['Flight 2 End Date'] = pd.to_datetime(combination_2['Flight 2 End Date'])

# Ensure it is not categorical
if pd.api.types.is_categorical_dtype(combination_2['Flight 2 End Date']):
    combination_2['Flight 2 End Date'] = combination_2['Flight 2 End Date'].astype('datetime64[ns]')

# Convert to integer if needed
combination_2['Flight_3_Start_Day_Num'] = pd.to_numeric(combination_2['Flight_3_Start_Day_Num'], errors='coerce')

# Get the weekday of Flight 3 End Date (Monday=0, ..., Sunday=6)
combination_2['Flight_2_End_Day_Num'] = combination_2['Flight 2 End Date'].dt.weekday

# Define mask: True if Start Day Num is after or on the same day as End Day Num
mask3 = combination_2['Flight_3_Start_Day_Num'] >= combination_2['Flight_2_End_Day_Num']

# Case 1: Flight 3 Start is in the same week
combination_2.loc[mask3, 'Flight 3 Start Date'] = (
    combination_2['Flight 2 End Date'] +
    pd.to_timedelta(combination_2['Flight_3_Start_Day_Num'] - combination_2['Flight_2_End_Day_Num'], unit='D')
)

# Case 2: Flight 3 Start is in the next week (~mask)
combination_2.loc[~mask3, 'Flight 3 Start Date'] = (
    combination_2['Flight 2 End Date'] +
    pd.to_timedelta(7 - (combination_2['Flight_2_End_Day_Num'] - combination_2['Flight_3_Start_Day_Num']), unit='D')
)

# # Flight 3 End Date
# Convert column to datetime
combination_2['Flight 3 Start Date'] = pd.to_datetime(combination_2['Flight 3 Start Date'])

# Ensure it is not categorical
if pd.api.types.is_categorical_dtype(combination_2['Flight 3 Start Date']):
    combination_2['Flight 3 Start Date'] = combination_2['Flight 3 Start Date'].astype('datetime64[ns]')


mask4 = combination_2['Flight_3_End_Day_Num'] >= combination_2['Flight_3_Start_Day_Num']

# Case 1: Flight 3 End is in the same week
combination_2.loc[mask4, 'Flight 3 End Date'] = (
    combination_2['Flight 3 Start Date'] +
    pd.to_timedelta(combination_2['Flight_3_End_Day_Num'] - combination_2['Flight_3_Start_Day_Num'], unit='D')
)

# Case 2: Flight 3 End is in the next week (~mask4)
combination_2.loc[~mask4, 'Flight 3 End Date'] = (
    combination_2['Flight 3 Start Date'] +
    pd.to_timedelta(7 - (combination_2['Flight_3_Start_Day_Num'] - combination_2['Flight_3_End_Day_Num']), unit='D')
)

# import datetime
# import pandas as pd

# # Function to convert day names (e.g., "Monday") into future dates
# def get_date_from_day(day_name, reference_date):
#     weekdays = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]

#     if day_name not in weekdays:
#         return None

#     ref_index = reference_date.weekday()
#     day_index = weekdays.index(day_name)

#     days_ahead = (day_index - ref_index + 7) % 7
#     if days_ahead == 0:
#         days_ahead = 7

#     return reference_date + datetime.timedelta(days=days_ahead)

# Load dataset
# combination_2 = combined_flights_2

# # Convert 'Flight 2 End Day' to actual dates
# combination_2['Flight 2 End Date'] = combination_2['Flight_2_End_Day'].apply(get_date_from_day, reference_date=datetime.date.today())

# combination_2
# if (combination_2['Flight_2_End_Day'] == combination_2['Flight_3_Start_Day']).all():
#     combination_2['Flight 3 Start Date'] = combination_2['Flight 2 End Date']
# else:
#   combination_2['Flight 3 Start Date'] = combination_2['Flight_3_Start_Day'].apply(get_date_from_day, reference_date=datetime.date.today())

# # --- Flight 3 Start and End Dates ---
# combination_2['Flight 3 Start Date'] = combination_2['Flight_3_Start_Day'].apply(get_date_from_day, reference_date=reference_date)
# combination_2['Flight 3 End Date'] = combination_2['Flight_3_End_Day'].apply(get_date_from_day, reference_date=reference_date)

# # Convert to datetime (fix categorical issue)
# combination_2['Flight 3 Start Date'] = pd.to_datetime(combination_2['Flight 3 Start Date'])
# combination_2['Flight 3 End Date'] = pd.to_datetime(combination_2['Flight 3 End Date'])

# # Ensure Flight 3 Start Date is after both Flight 1 and Flight 2 End Dates
# combination_2['Flight 3 Start Date'] = combination_2[['Flight 1 End Date', 'Flight 2 End Date']].max(axis=1) + pd.Timedelta(days=1)

# if (combination_2['Flight_3_Start_Day'] == combination_2['Flight_3_End_Day']).all():
#     combination_2['Flight 3 End Date'] = combination_2['Flight 3 Start Date']
# else:
#   # Ensure Flight 3 End Date is after Flight 3 Start Date
#   combination_2.loc[combination_2['Flight 3 End Date'] < combination_2['Flight 3 Start Date'], 'Flight 3 End Date'] += pd.Timedelta(days=7)

# Convert time columns to proper time format
combination_2['Flight_2_Arrival_time(SLST)'] = pd.to_datetime(
    combination_2['Flight_2_Arrival_time(SLST)'], format="%H:%M:%S", errors='coerce'
).dt.time

combination_2['Flight_3_start_time(SLST)'] = pd.to_datetime(
    combination_2['Flight_3_start_time(SLST)'], format="%H:%M:%S", errors='coerce'
).dt.time

combination_2_new = combination_2.copy()

# Convert to string before concatenation
combination_2_new['Flight 2 End Date'] = combination_2_new['Flight 2 End Date'].astype(str)
combination_2_new['Flight_2_Arrival_time(SLST)'] = combination_2_new['Flight_2_Arrival_time(SLST)'].astype(str)

# Create Flight 2 Arrival datetime
combination_2_new['Flight 2 Arrival datetime'] = combination_2_new['Flight 2 End Date'] + ' ' + combination_2_new['Flight_2_Arrival_time(SLST)']
combination_2_new['Flight 2 Arrival datetime'] = pd.to_datetime(combination_2_new['Flight 2 Arrival datetime'])

# Ensure both columns are in string format for Flight 3 start datetime
combination_2_new['Flight 3 Start Date'] = combination_2_new['Flight 3 Start Date'].astype(str)
combination_2_new['Flight_3_start_time(SLST)'] = combination_2_new['Flight_3_start_time(SLST)'].astype(str)

# Combine date and time columns for Flight 3
combination_2_new['Flight 3 start datetime'] = combination_2_new['Flight 3 Start Date'] + ' ' + combination_2_new['Flight_3_start_time(SLST)']
combination_2_new['Flight 3 start datetime'] = pd.to_datetime(combination_2_new['Flight 3 start datetime'])

combination_2['Flight 3 start datetime']=combination_2_new['Flight 3 start datetime']
combination_2['Flight 2 Arrival datetime']=combination_2_new['Flight 2 Arrival datetime']

combination_2.to_csv("combination_2_new.csv", index = False)

# Ensure datetime format
combination_2['Flight 1 Start Date'] = pd.to_datetime(combination_2['Flight 1 Start Date']).astype('datetime64[ns]')
combination_2['Flight 3 End Date'] = pd.to_datetime(combination_2['Flight 3 End Date']).astype('datetime64[ns]')

# Calculate the difference in days
combination_2['Day Gap'] = (combination_2['Flight 3 End Date'] - combination_2['Flight 1 Start Date']).dt.days

# Filter rows where the gap is outside the range [0, 6]
invalid_flights_condition_3 = combination_2[
    (combination_2['Day Gap'] < 0) | (combination_2['Day Gap'] > 6)
]

# Display invalid cases
if not invalid_flights_condition_3.empty:
    print("Invalid flights where Flight 3 End Date is not within 0 to 6 days from Flight 1 Start Date:")
    print(invalid_flights_condition_3[['Flight 1 Start Date', 'Flight 3 End Date', 'Day Gap']])

combination_2.shape

# Drop invalid flights from the main DataFrame
combination_2 = combination_2[~combination_2.index.isin(invalid_flights_condition_3.index)]
# Optionally, reset the index if desired
combination_2.reset_index(drop=True, inplace=True)

combination_2.shape

# Condition 2: Ensure Flight 3 End Date is within 7 days of Flight 1 Start Date
invalid_flights_condition_2 = combination_2[
    combination_2['Flight 3 End Date'] > (combination_2['Flight 1 Start Date'] + pd.Timedelta(days=6))
]

if not invalid_flights_condition_2.empty:
    print("Invalid flight entries detected where Flight 3 End Date exceeds 7 days from Flight 1 Start Date:")
    print(invalid_flights_condition_2[[ 'Flight 1 Start Date', 'Flight 3 End Date']])

# Drop invalid flights from the main DataFrame for Condition 2
combination_2 = combination_2[~combination_2.index.isin(invalid_flights_condition_2.index)]

# Optionally, reset the index if desired
combination_2.reset_index(drop=True, inplace=True)

filtered_flights_2 = combination_2
# Drop unnecessary columns (ignoring errors if they don't exist)
# filtered_flights_2.drop(columns=["Flight 3 Date", "Flight 3 start datetime", ], inplace=True, errors='ignore')

# Verify data types to ensure proper filtering
# print("Filtered data types:")
# print(filtered_flights_2.dtypes)

filtered_flights_2.shape

filtered_flights_2.columns

filtered_flights_2 = filtered_flights_2[
    (
        # Case where the dates are the same
        (
            (filtered_flights_2['Flight 3 Start Date'].astype('datetime64[ns]') == filtered_flights_2['Flight 2 End Date'].astype('datetime64[ns]')) &
            (filtered_flights_2['Flight 2 Arrival datetime'].astype('datetime64[ns]') < filtered_flights_2['Flight 3 start datetime'].astype('datetime64[ns]'))
        )
        |
        # Case where the dates are different
        (
            (filtered_flights_2['Flight 3 Start Date'].astype('datetime64[ns]') > filtered_flights_2['Flight 2 End Date'].astype('datetime64[ns]')) &  # Allow same day
            (filtered_flights_2['Flight 3 Start Date'].astype('datetime64[ns]') < (filtered_flights_2['Flight 2 End Date'].astype('datetime64[ns]') + pd.Timedelta(days=7))) &  # Less than 7 days apart
            (filtered_flights_2['Flight 2 Arrival datetime'].astype('datetime64[ns]') < filtered_flights_2['Flight 3 Start Date'].astype('datetime64[ns]'))  # Flight 2 arrives before Flight 3 starts
        )
    )
]
# Optionally, reset the index if desired
filtered_flights_2.reset_index(drop=True, inplace=True)

filtered_flights_2

# # Calculate waiting time
# filtered_flights['Waiting Time'] = filtered_flights['Flight 2 start datetime'] - filtered_flights['Flight 1 Arrival datetime']

# # Convert waiting time to hours for better readability
# filtered_flights['Waiting Time (hours)'] = filtered_flights['Waiting Time'].dt.total_seconds() / 3600

# # Apply filtering condition: Keep all rows, but filter when Flight 1 Day == Flight 2 Day
# filtered_flights_1 = filtered_flights[
#     (filtered_flights['Flight 1 End Date'] != filtered_flights['Flight 2 Start Date']) |  # Keep data where days are different
#     (filtered_flights['Flight 1 Arrival datetime'] < filtered_flights['Flight 2 start datetime'])  # Apply condition when days match
# ]

# # Display or save the filtered DataFrame
# # filtered_flights.to_csv("filtered_flights.csv", index=False)
# filtered_flights_1[[ 'Flight 1 Arrival datetime', 'Flight 2 start datetime', 'Waiting Time (hours)']]
# # # Save the filtered results to CSV
# # filtered_flights_1.to_csv("filtered_flights_1.csv", index=False)

filtered_flights_2.shape

filtered_flights_2.to_csv("filtered_flights_2.csv", index=False)

# Calculate waiting time
filtered_flights_2['Waiting Time'] = filtered_flights_2['Flight 3 start datetime'] - filtered_flights_2['Flight 2 Arrival datetime']

# Convert waiting time to hours for better readability
filtered_flights_2['Waiting Time (hours)_2'] = filtered_flights_2['Waiting Time'].dt.total_seconds() / 3600

# Apply filtering condition: Keep all rows, but filter when Flight 1 Day == Flight 2 Day
filtered_flights_2 = filtered_flights_2[
    (filtered_flights_2['Flight 2 End Date'] != filtered_flights_2['Flight 3 Start Date']) |  # Keep data where days are different
    (filtered_flights_2['Flight 2 Arrival datetime'] < filtered_flights_2['Flight 3 start datetime'])  # Apply condition when days match
]

# Display or save the filtered DataFrame
# filtered_flights.to_csv("filtered_flights.csv", index=False)
filtered_flights_2[['Flight 2 Arrival datetime', 'Flight 3 start datetime', 'Waiting Time (hours)_2']]
# # Save the filtered results to CSV
# filtered_flights_1.to_csv("filtered_flights_1.csv", index=False)

# Function to calculate waiting days based on waiting time in hours
def calculate_waiting_days(waiting_time):
    waiting_days = 0
    thresholds = [24, 48, 72, 96, 120, 144, 168]  # Define thresholds in hours

    for threshold in thresholds:
        if waiting_time < threshold:
            break  # Stop if the waiting time is less than the threshold
        waiting_days += 1  # Increment waiting days for each threshold exceeded

    return waiting_days

# Assuming 'Waiting Time' is already in hours in the filtered_flights_2 DataFrame
filtered_flights_2['Waiting_Days_2'] = filtered_flights_2['Waiting Time (hours)_2'].apply(calculate_waiting_days)

# Drop unnecessary columns (ignoring errors if they don't exist)
filtered_flights_2.drop(columns=['Waiting Time', 'Flight 2 Arrival datetime', 'Flight 3 start datetime', 'Flight 2 start datetime'], inplace=True, errors='ignore')
# filtered_flights_2["1st_tour_total_flight_hours"] = filtered_flights_2["Flight_1_duration_hours"] + filtered_flights_1["Flight_2_duration_hours"]
# Display or save the updated DataFrame as needed
# filtered_flights_2.to_csv("filtered_flights_2.csv", index=False)

print("Filtered flights with waiting time and waiting days saved successfully!")

filtered_flights_2.to_csv("filtered_flights_2.csv", index = False)

filtered_flights_3 = filtered_flights_2.copy(deep=True)

filtered_flights_3.columns

filtered_flights_3.shape

filtered_flights_3 = filtered_flights_3.drop(
    ['Flight_3_Start_Day', 'Flight_3_ID', 'Flight_3_From',
       'Flight_3_From_IATA', 'Flight_3_To', 'Flight_3_To_IATA',
       'Flight_3_start_time(SLST)', 'Flight_3_Arrival_time(SLST)',
       'Flight_3_Min', 'Flight_3_Max', 'Flight_3_duration_hours',
       'Flight_3_End_Day', 'Flight_3_End_Day_Num', 'Flight_3_Start_Day_Num',
       'Flight 3 Start Date', 'Flight 3 End Date', 'Day Gap',
       'Waiting Time (hours)_2', 'Waiting_Days_2'],
    axis=1  # Drop columns, not rows
)

filtered_flights_3.shape

colums_2=filtered_flights_3.columns

# Get unique rows based on column 'A' (keeping the first occurrence)
filtered_flights_3 = filtered_flights_3.drop_duplicates(subset=['Flight_2_Allocated_Members'])

# Optionally, reset the index if desired
filtered_flights_3.reset_index(drop=True, inplace=True)
filtered_flights_3[colums_2]

filtered_flights_3.shape

filtered_flights_3['Flight_3_Start_Day'] = np.nan
filtered_flights_3['Flight_3_ID'] = np.nan
filtered_flights_3['Flight_3_From'] = np.nan
filtered_flights_3['Flight_3_To'] = np.nan
filtered_flights_3['Flight_3_start_time(SLST)'] = np.nan
filtered_flights_3['Flight_3_Arrival_time(SLST)'] = np.nan
filtered_flights_3['Flight_3_Min'] = np.nan
filtered_flights_3['Flight_3_Max'] = np.nan
filtered_flights_3['Flight_3_duration_hours'] = np.nan
filtered_flights_3['Flight_3_End_Day_Num'] = np.nan
filtered_flights_3['Flight_3_Start_Day_Num'] = np.nan
filtered_flights_3['Flight 3 Start Date'] = np.nan
filtered_flights_3['Flight 3 End Date'] = np.nan
filtered_flights_3['Flight 3 start datetime'] = np.nan
filtered_flights_3['Flight 2 Arrival datetime'] = np.nan
filtered_flights_3['Day Gap'] = np.nan
filtered_flights_3['Waiting Time'] = np.nan
filtered_flights_3['Waiting Time (hours)_2'] = np.nan

filtered_flights_3

# Append rows from df2 to df1
df_combined = pd.concat([filtered_flights_3, filtered_flights_2], ignore_index=True)

filtered_flights_2.shape

df_combined.shape

df_combined.dtypes

df_combined = df_combined.drop(["Flight_3_End_Day_Num", "Flight_3_Start_Day_Num",'Flight 3 start datetime',
       'Flight 2 Arrival datetime','Flight_2_Start_Day_Num', 'Flight_2_End_Day_Num' ], axis=1)
# # Group by 'Category' and 'Type', then sum the 'Value' column
# grouped_df = df_combined.groupby(['Flight_1_Start_Day', 'Flight_1_ID']).sum(numeric_only=True).reset_index()

import numpy as np

df_combined["Flight_3_Allocated_Members"] = np.where(
    df_combined["Flight_3_Start_Day"].notna(),
    df_combined["Flight_2_Allocated_Members"].astype(str) + "_" +
    df_combined["Flight_3_Start_Day"].str[:2] + "/" +
    df_combined["Flight_3_From_IATA"].str[:3] + "/" +
    df_combined["Flight_3_ID"].str[-3:] + "/" +
    df_combined["Flight_3_To_IATA"].str[:3],
    df_combined["Flight_2_Allocated_Members"].astype(str) + "_" + "NaN"
)

df_combined["Flight_3_Allocated_Members"]

unique_count =df_combined["Flight_3_Allocated_Members"].nunique()

unique_count

df_combined.to_csv("df_combined.csv", index=False)

# # Assign Allocated_Members dynamically without storing Day_Frequency - Flight 3
# df_combined["Flight_3_Allocated_Members"] = df_combined["Flight_2_Allocated_Members"].str[0:4] + (df_combined.groupby("Flight_2_Allocated_Members").cumcount() + 1).astype(str)

# # Count occurrences for 'Flight 1 Allocated_Members'
# counts = df_combined.groupby("Flight_3_Allocated_Members").cumcount() + 1

# # Convert numbers > 9 to letters (A=10, B=11, C=12, ...)
# def num_to_label(n):
#     if n <= 9:
#         return str(n)
#     else:
#         return string.ascii_uppercase[n - 10]  # Convert 10 → A, 11 → B, etc.

# # Create 'Flight 2 Allocated' column
# df_combined["Flight_3_Allocated_Members"] = (
#     df_combined["Flight_2_Allocated_Members"].str[0:4] + counts.apply(num_to_label).astype(str)
# )

# df_combined

# Save the final filtered dataset
df_combined.to_csv("filtered_flights_2.csv", index=False)

# Define a function to check the condition
def set_tour_type(row):
    if row["Flight_1_From"] == row["Flight_3_To"]:
        return "Return Triple Tours (C3)"
    elif pd.isna(row["Flight_3_From"]) and row["Flight_1_From"] != row["Flight_2_To"]:
        return "No Return double Tours (P3)"
    else:
        return "No Return Triple Tours (P4)"

# Apply the function to create the new column
df_combined["Tour Type"] = df_combined.apply(set_tour_type, axis=1)

# Move "Tour Type" to the first column
tour_type_column = df_combined.pop("Tour Type")  # Remove the column
df_combined.insert(0, "Tour Type", tour_type_column)  # Insert it at the first position

print("Tour Type column successfully moved to the first position!")

df_combined.to_csv("filtered_flights_2.csv", index=False)

# # Separate DataFrames based on Tour Type and reset index
# df_return_triple = filtered_flights_2[filtered_flights_2["Tour Type"] == "Return Triple Tours (C3)"].reset_index(drop=True)
# df_no_return_triple = filtered_flights_2[filtered_flights_2["Tour Type"] == "No Return Triple Tours (P4)"].reset_index(drop=True)

# # Display the shapes of the new DataFrames
# print("Return Triple Tours:", df_return_triple.shape)
# print("No Return Triple Tours:", df_no_return_triple.shape)

# df_return_triple.to_csv("Return_triple.csv", index=False)
# df_no_return_triple.to_csv("No_return_triple.csv", index=False)

df_combined.columns

filtered_flights_1.columns

filtered_flights_1

filtered_flights_1[['Tour Type', 'Flight_1_duration_hours', 'Flight_1_Allocated_Members', 'Flight_2_duration_hours', 'Waiting Days','Flight_2_Allocated_Members']]

first_second = pd.read_csv("filtered_flights_1.csv")
first_second_third = pd.read_csv("filtered_flights_2.csv")
salary = pd.read_excel("salary.xlsx")

first_second_selected = first_second[['Tour Type','Flight_1_Min', 'Flight_1_Max','Flight_1_duration_hours','Flight_1_Allocated_Members', 'Waiting Days','Flight_2_Min', 'Flight_2_Max', 'Flight_2_duration_hours','Flight_2_Allocated_Members']]

first_second_selected["Total_salary"] = (
    first_second_selected["Flight_1_duration_hours"] * salary['payment'][0] +
    first_second_selected["Flight_2_duration_hours"] * salary['payment'][0] +
    first_second_selected["Waiting Days"] * salary['payment'][1]
)

print(first_second_selected.isnull().sum())

first_second_selected

# flight 1 unique member names index
unique_indices = first_second_selected.loc[first_second_selected["Flight_1_Allocated_Members"].drop_duplicates().index].index #To use the variable_1

unique_indices #Flight 1 crew mwmbwes index

# Flight 1 boundaries
# get that unique flight 1 member name in the first_second_select df flight_1 allocated_members
variable_1=[]
for i in unique_indices:
    variable_1.append(first_second_selected["Flight_1_Allocated_Members"][i])

# get that unique flight 1 member name in the first_second_select df flight_1 allocated_memberstotal salary
Unique_members_of_Flight_1_salary=[]
for i in unique_indices:
    Unique_members_of_Flight_1_salary.append(first_second_selected["Total_salary"][i])

# the flight 1 allocated members lower boundary
lower_bound1 = []
upper_bound1 = []
for i in unique_indices:
    lower_bound1.append(first_second_selected['Flight_1_Min'][i])
    upper_bound1.append(first_second_selected['Flight_1_Max'][i])

flight1_details = pd.DataFrame({
    "Flight_1_Allocated_Members": variable_1,
    "Total_salary": Unique_members_of_Flight_1_salary,
    "Flight_1_Min": lower_bound1,
    "Flight_1_Max": upper_bound1
})

flight1_details

# that unique flight 1 members assignment into flight 2
# Dictionary to store indices separately
one_to_2_indices_dict = {}

for j in variable_1:
    one_to_2_indices_dict[j] = first_second_selected[first_second_selected['Flight_2_Allocated_Members'].str.startswith(j, na=False)].index.tolist()

# Print results
for j, indices in one_to_2_indices_dict.items():
    print(f"Indices for 1st flight '{j}': {indices}")

one_to_2_indices_dict = pd.DataFrame([(key, indices) for key, indices in one_to_2_indices_dict.items()], columns=["Member", "Indices"])
one_to_2_indices_dict.to_csv("one_to_2_indices_dict.csv", index=False)

one_to_2_indices_dict

# # the flight 2 allocated members lower boundary
# lower_bound2 = []
# upper_bound2 = []
# for i in range(len(first_second_selected)):
#     lower_bound2.append(first_second_selected['Flight_2_Min'][i])
#     upper_bound2.append(first_second_selected['Flight_2_Max'][i])

# flight 2 lowe and upper boundary
variables_2=[]
# lower_bound_2 = []
# upper_bound_2 = []
for i in range(len(one_to_2_indices_dict)):
  for j in one_to_2_indices_dict['Indices'][i]:
    variables_2.append(first_second_selected['Flight_2_Allocated_Members'][j])
    # lower_bound_2.append(lower_bound2[j])
    # upper_bound_2.append(upper_bound2[j])

salary_flight_2=[]
for i in first_second_selected['Total_salary']:
  salary_flight_2.append(i)
print(salary_flight_2)

flight_2_members=[]
for i in first_second_selected['Flight_2_Allocated_Members']:
  flight_2_members.append(i)
print(flight_2_members)

# Calculate count of indices for each member
one_to_2_indices_dict["Indices_Count"] = one_to_2_indices_dict["Indices"].apply(len)
one_to_2_indices_dict

first_second_third_selected = first_second_third[['Tour Type','Flight_1_Min', 'Flight_1_Max','Flight_1_duration_hours', 'Waiting Days','Flight_2_Min', 'Flight_2_Max', 'Flight_2_duration_hours','Flight_2_Allocated_Members', 'Flight_3_Min', 'Flight_3_Max', 'Flight_3_duration_hours', 'Waiting_Days_2', 'Flight_3_Allocated_Members' ]]

print(first_second_third_selected.isnull().sum())

first_second_third_selected.fillna(0, inplace=True)
print(first_second_third_selected.isnull().sum())

# Salary Calculation
if (first_second_third_selected["Tour Type"] == "No Return Triple Tours (P4)").any():
    first_second_third_selected.loc[first_second_third_selected["Tour Type"] == "No Return Triple Tours (P4)", "Total_salary"] = (
        (first_second_third_selected["Flight_1_duration_hours"] + first_second_third_selected["Flight_2_duration_hours"] + first_second_third_selected["Flight_3_duration_hours"]) * salary['payment'][0] + (first_second_third_selected["Waiting Days"] + first_second_third_selected["Waiting_Days_2"]) * salary['payment'][1] + salary['payment'][2]
    )
if(first_second_third_selected["Tour Type"] == "No Return double Tours (P3)").any():
    first_second_third_selected.loc[first_second_third_selected["Tour Type"] == "No Return double Tours (P3)", "Total_salary"] = (
      ((first_second_third_selected["Flight_1_duration_hours"] + first_second_third_selected["Flight_2_duration_hours"])*salary['payment'][0]) + ((first_second_third_selected["Waiting Days"] ) * salary['payment'][1]) + (salary['payment'][2])
    )
if (first_second_third_selected["Tour Type"] == "Return Triple Tours (C3)").any():
    first_second_third_selected.loc[first_second_third_selected["Tour Type"] == "Return Triple Tours (C3)", "Total_salary"] = (
        (first_second_third_selected["Flight_1_duration_hours"] + first_second_third_selected["Flight_2_duration_hours"] + first_second_third_selected["Flight_3_duration_hours"]) * salary['payment'][0] + (first_second_third_selected["Waiting Days"] + first_second_third_selected["Waiting_Days_2"]) * salary['payment'][1]
    )

unique_indices_2 = first_second_third_selected.loc[first_second_third_selected["Flight_2_Allocated_Members"].drop_duplicates().index].index

Unique_members_of_Flight_2=[]
for i in unique_indices_2:
    Unique_members_of_Flight_2.append(first_second_third_selected["Flight_2_Allocated_Members"][i])

# Dictionary to store indices separately
one_to_2_3_indices_dict = {}

for j in Unique_members_of_Flight_2:
    one_to_2_3_indices_dict[j] = first_second_third_selected[first_second_third_selected['Flight_3_Allocated_Members'].str.startswith(j, na=False)].index.tolist()

# Print results
for j, indices in one_to_2_3_indices_dict.items():
    print(f"Indices for 2st flight_first_second_third_selected '{j}': {indices}")

one_to_2_3_indices_dict = pd.DataFrame([(key, indices) for key, indices in one_to_2_3_indices_dict.items()], columns=["Member", "Indices"])
one_to_2_3_indices_dict.to_csv("one_to_2_3_indices_dict.csv", index=False)

one_to_2_3_indices_dict

variables_3= first_second_third_selected['Flight_3_Allocated_Members']

salary_flight_3=[]
for i in first_second_third_selected['Total_salary']:
  salary_flight_3.append(i)
print(salary_flight_3)

flight_3_members=[]
for i in first_second_third_selected['Flight_3_Allocated_Members']:
  flight_3_members.append(i)
print(flight_3_members)

# Calculate count of indices for each member
one_to_2_3_indices_dict["Indices_Count2"] = one_to_2_3_indices_dict["Indices"].apply(len)
one_to_2_3_indices_dict

# Convert to DataFrame with explicit column name
df = pd.DataFrame(flight_2_members, columns=["Flight_2_Allocated_Members"])

# Function to extract substring after "_"
def extract_after_underscore(value):
    if isinstance(value, str) and "_" in value:
        return value.split("_", 1)[1]  # Get part after "_"
    return None  # Return None if "_" is not found

# Extract the second part
df['extracted_part'] = df["Flight_2_Allocated_Members"].apply(extract_after_underscore)

# Drop duplicate extracted parts but keep first occurrence
df_unique = df[['extracted_part']].drop_duplicates().dropna().reset_index(drop=True)

# Get the indices where each extracted part appears (ensuring exact suffix matching)
df_unique['full_part_index'] = df_unique['extracted_part'].apply(
    lambda x: df.index[df['Flight_2_Allocated_Members'].apply(
        lambda y: y.endswith(x) if isinstance(y, str) else False
    )].tolist()
)

# Get the count of occurrences for each extracted part
df_unique['count'] = df_unique['full_part_index'].apply(len)

# Display the result
df_unique

flight_2_members = first_second_selected["Flight_2_Allocated_Members"].tolist()
# Find common variable names directly
common_variable_names = set(flight_2_members) & set(one_to_2_3_indices_dict['Member'])
common_variable_names = list(common_variable_names)
# Create a dictionary for variable2_2 with common variable names as keys and counts as lower bounds
variables2_2 = {name: (0, one_to_2_3_indices_dict['Indices_Count2'][i])
               for i, name in enumerate(one_to_2_3_indices_dict['Member'])
               if name in common_variable_names}

# Get indices of common variable names in first_second_selected["Flight_2_Allocated_Members"]
common_indices = [i for i, member in enumerate(flight_2_members) if member in common_variable_names]

variables2_2
from pulp import LpVariable

# Create LpVariables for variables2_2 with the correct lower bound values
variables2_2 = {name: LpVariable(name, lowBound=count, cat='Integer')
                for name, count in zip(one_to_2_3_indices_dict['Member'], one_to_2_3_indices_dict['Indices_Count2'])
                if name in common_variable_names}

# Drop the common elements from flight_2_members
remaining_flight_2_members = [member for member in flight_2_members if member not in common_variable_names]
remaining_flight_2_members = list(remaining_flight_2_members)
# Define variables2_1 using the remaining flight_2_members as names
variables2_1 = {
    member: LpVariable(
        member,
        lowBound=0,
        cat='Integer'
    )
    for member in remaining_flight_2_members
}
remaining_indices = [i for i, member in enumerate(flight_2_members) if member in remaining_flight_2_members]

one_to_2_3_indices_dict

len(remaining_flight_2_members)

len(common_variable_names)

# Merge on extracted_part (df_unique) and Members (flight1_details)
merged_df = df_unique.merge(flight1_details, left_on='extracted_part', right_on='Flight_1_Allocated_Members', how='left')

# Drop the 'Members' column and any other columns from flight1_details you don't want
merged_df = merged_df.drop(columns=['Flight_1_Allocated_Members', 'Total_salary'])

# Display the result
merged_df

salary_flight_2_2=[]
for i in common_indices:
  salary_flight_2_2.append(first_second_selected['Total_salary'][i])
salary_flight_2_1=[]
for j in remaining_indices:
  salary_flight_2_1.append(first_second_selected['Total_salary'][j])

from pulp import LpMinimize, LpProblem, LpVariable, lpSum
# Define the problem
problem = LpProblem("Crew_Optimization", LpMinimize)

# Preprocess salaries to replace None with 0
salary_flight_2_2 = [s if s is not None else 0 for s in salary_flight_2_2]
salary_flight_2_1 = [s if s is not None else 0 for s in salary_flight_2_1]

# Define weights for objective function
alpha = 1     # Cost minimization weight
beta = -0.1   # Crew utilization encouragement (adjustable)

# Objective function: Minimize cost while maximizing crew allocation
problem += (
    alpha * lpSum([
        salary_flight_2_2[i] * variables2_2.get(common_variable_names[i], 0)
        for i in range(len(common_variable_names))
    ]) +
    alpha * lpSum([
        salary_flight_2_1[i] * variables2_1.get(remaining_flight_2_members[i], 0)
        for i in range(len(remaining_flight_2_members))
    ]) +
    beta * (lpSum(variables2_2.values()) + lpSum(variables2_1.values()))
), "Total Cost and Maximum Utilization"

problem

one_to_2_3_indices_dict

common_members = flight1_details['Flight_1_Allocated_Members'].isin(merged_df['extracted_part'])
common_index = flight1_details.index[common_members]
print(common_index)

all_indices_flight1 = flight1_details.index.tolist()
remaining_index = flight1_details.index[~flight1_details['Flight_1_Allocated_Members'].isin(merged_df['extracted_part'])]
print(remaining_index)

min_values = []

# Get all relevant indices (0 to 25) from merged_df
all_indices = set(merged_df.index)

# Iterate over all indices (ensuring we include both common and remaining ones)
for i in all_indices:
    if i in common_indices:
        # If index is in common_indices, consider all three values
        min_values.append(max(
            one_to_2_indices_dict['Indices_Count'].get(i, 0),
            one_to_2_3_indices_dict['Indices_Count2'].get(i, 0),
            merged_df['count'].get(i, 0)  # Default to 0 if index not found
        ))
    else:
        # If index is NOT in common_indices, only consider the first two
        min_values.append(max(
            one_to_2_indices_dict['Indices_Count'].get(i, 0),
            one_to_2_3_indices_dict['Indices_Count2'].get(i, 0)
        ))

print(min_values)

# Create a mapping from Members to count in merged_df
member_to_count = dict(zip(merged_df['extracted_part'], merged_df['count']))

# Iterate over all expected indices (0 to 21)
for i in range(unique_count):
    member = one_to_2_indices_dict['Member'].get(i)  # Get corresponding Member

    if i in common_indices:
        min_values.append(max(
            one_to_2_indices_dict['Indices_Count'].get(i, 0),
            one_to_2_3_indices_dict['Indices_Count2'].get(i, 0),
            member_to_count.get(member, 0)# Map using Members instead of index
        ))
    else:
        min_values.append(max(
            one_to_2_indices_dict['Indices_Count'].get(i, 0),
            one_to_2_3_indices_dict['Indices_Count2'].get(i, 0)
        ))

variables2_2

# Prepare max values
max_values1 = [
    max(flight1_details['Flight_1_Max'][i],
        one_to_2_indices_dict['Indices_Count'][i],
        one_to_2_3_indices_dict['Indices_Count2'][i])
    for i in range(len(one_to_2_indices_dict))
]

# Prepare min values
min_values = flight1_details['Flight_1_Min']

# Final max values, adjusted if necessary
max_values = []
for i in range(len(max_values1)):
    if max_values1[i] < min_values[i]:
        max_values.append(min_values[i])
    else:
        max_values.append(max_values1[i])
# _______END>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

# Take user inputs within min/max bounds
user_inputs1 = {}

for i, key in enumerate(flight1_details['Flight_1_Allocated_Members']):
    m_min = min_values[i]
    m_max = max_values[i]
    while True:
        try:
            value = int(input(f"Enter value for {key} ({m_min}, {m_max}): "))
            if m_min <= value <= m_max:
                user_inputs1[key] = value
                break
            else:
                print(f"Value must be between {m_min} and {m_max}. Try again.")
        except ValueError:
            print("Invalid input. Please enter a valid integer.")

print("Final user inputs:", user_inputs1)

indices_lst = []

for i in range(len(one_to_2_indices_dict)):
    row_indices = one_to_2_indices_dict["Indices"][i]
    indices_lst.append(row_indices)

print(indices_lst)


# problem += first_second_selected['Flight_2_Allocated_Members'][index]==var_value1[0]

for i, indices in enumerate(indices_lst):
    selected_flight_2_members = first_second_selected.loc[indices, 'Flight_2_Allocated_Members']

    # Debugging print
    print(f"Index Group {i}: {indices}")
    print(f"Selected Flight 2 Members: {selected_flight_2_members.tolist()}")

    # Ensure all selected flights exist in either variables2 or variables4
    valid_variables = []
    missing_keys = []

    for flight in selected_flight_2_members:
        if flight in variables2_2:
            valid_variables.append(variables2_2[flight])
        elif flight in variables2_1:
            valid_variables.append(variables2_1[flight])
        else:
            missing_keys.append(flight)

    # Ensure Flight_1_Allocated_Members exist in user_inputs
    flight_1_key = first_second_selected['Flight_1_Allocated_Members'].iloc[i]
    if flight_1_key not in user_inputs1:
        print(f"Warning: Key {flight_1_key} missing from user_inputs")
        continue  # Skip this constraint if user_inputs key is missing

    # Print missing variables for debugging
    if missing_keys:
        print(f"Warning: These flights are missing from both variables2: {missing_keys}")

        # Only create constraint if valid variables exist
    if valid_variables:
        # Add the lower bound constraint: the sum of valid variables must be >= 1
        problem += lpSum(valid_variables) >= 1

        # # Add the upper bound constraint: the sum of valid variables must be <= user_inputs1[flight_1_key]
        problem += lpSum(valid_variables) >= user_inputs1[flight_1_key]



df_unique

merged_df

from pulp import lpSum

for i, row in df_unique.iterrows():
    indices = row['full_part_index']
    extracted_part = row['extracted_part']

    if not indices:
        continue  # Skip if no matching indices

    # Extract selected flight members based on the indices
    selected_flight_2_members = first_second_selected.loc[indices, "Flight_2_Allocated_Members"]
    # Debugging print
    print(f"Index Group {i}: {indices}")
    print(f"Selected Flight 2 Members: {selected_flight_2_members.tolist()}")

    # Ensure all selected flights exist in either variables2_2 or variables2_1
    valid_variables = []
    missing_keys = []
    print(flight)
    for flight in selected_flight_2_members:
        if flight in variables2_2:
            valid_variables.append(variables2_2[flight].varValue)  # Use varValue as per your requirement
        elif flight in variables2_1:
            valid_variables.append(variables2_1[flight].varValue)
        else:
            missing_keys.append(flight)

max_limit = merged_df['Flight_1_Max'].tolist()
min_limit = merged_df['Flight_1_Min'].tolist()

# Ensure `flight1_1` maps correctly to its respective LpVariable
flight1_in = []
for flight1_new in merged_df['extracted_part']:
    if flight1_new in user_inputs1:  # Assuming variables2_1 holds relevant LpVariables
        flight1_in.append(user_inputs1[flight1_new])
    else:
        flight1_in.append(0)  # Handle missing cases safely

# Loop over each row in df_unique to add constraints dynamically
for i, row in df_unique.iterrows():
    indices = row['full_part_index']
    if isinstance(indices, str):
        indices = list(map(int, indices.split(',')))

    # Extract selected flight members
    selected_flight_2_members = first_second_selected.loc[indices, "Flight_2_Allocated_Members"].dropna()

    valid_variables = []
    for flight in selected_flight_2_members:
        flight = flight.strip()
        if flight in variables2_2:
            valid_variables.append(variables2_2[flight])
        elif flight in variables2_1:
            valid_variables.append(variables2_1[flight])

    # Ensure valid index for flight1_in
    flight1_var = flight1_in[i] if i < len(flight1_in) else 0

    if valid_variables:
        upper_constraint_name = f"Constraint_{36 + i}_Upper"
        lower_constraint_name = f"Constraint_{36 + i}_Lower"

        # problem += sum(valid_variables) + flight1_var <= max_limit[i], upper_constraint_name
        # if min_limit[i] - flight1_var >= 0:
        #     problem += sum(valid_variables) + flight1_var >= min_limit[i], lower_constraint_name
        # else:
        #   problem += sum(valid_variables) >= 1, lower_constraint_name

        problem += sum(valid_variables)<= max_limit[i], upper_constraint_name

        problem += sum(valid_variables) >= min_limit[i], lower_constraint_name

indices_2nd = []

for i in range(len(one_to_2_3_indices_dict)):
    row_indices = one_to_2_3_indices_dict["Indices"][i]
    indices_2nd.append(row_indices)

print(indices_2nd)

user_inputs1

total_sum = sum(user_inputs1.values())
print("Total Sum:", total_sum)

# Define constraint to enforce total assigned value == user input
problem += (
    lpSum(variables2_2.values()) + lpSum(variables2_1.values()) == total_sum
), "Total Assignment Equality"

# Solve the problem
problem.solve()

# # Check the results
# total_assigned_value == sum(var.varValue for var in variables2_2.values()) + sum(var.varValue for var in variables2_1.values())

# print("Total Sum (Expected):", total_sum)  # Should be 149
# print("Total Assigned Value (Optimized):", total_assigned_value)  # Should also be 149

problem

from pulp import PULP_CBC_CMD
problem.solve(PULP_CBC_CMD(msg=True))  # Use solver output to debug

problem.solve()

from pulp import LpStatus

print("Solver Status:", LpStatus[problem.status])

# # Check if the LP problem is feasible
# if problem.status != 1:  # status 1 means optimal, other values indicate infeasibility or other issues
#     print("The LP problem is infeasible.")
#     # To get the minimum value of the relevant variables, you can loop through them
#     for var in all_variables:
#         if var in variables2_2:
#             # If the variable is in variables2_2 and the problem is infeasible, get its minimum value
#             print(f"{var}: {variables2_2[var].lowBound}")  # Using lowBound to get the minimum value
#         elif var in variables2_1:
#             print(f"{var}: {variables2_1[var].lowBound}")
# else:
print("Optimal Solution:")
all_variables = set(variables2_1) | set(variables2_2)  # Get all unique variables from both lists

for var in all_variables:
    if var in variables2_2:
        print(f"{var}: {variables2_2[var].varValue}")
    elif var in variables2_1:
        print(f"{var}: {variables2_1[var].varValue}")

total_assigned_value = 0

for var in all_variables:
    if var in variables2_2:
        total_assigned_value += variables2_2[var].varValue
    elif var in variables2_1:
        total_assigned_value += variables2_1[var].varValue

print("Total Assigned Value:", total_assigned_value)

# Ensure that the problem has been solved before accessing the objective value
if hasattr(problem, 'objective') and problem.objective is not None:
    print(f"Total Cost: {problem.objective.value()}")
else:
    print("Objective value is not available.")

def get_optimal_values(variables1, variables2):
    # Merge both variable dictionaries
    all_variables = {**variables1, **variables2}  # Merge variables2_1 and variables2_2
    return {var: all_variables[var].varValue for var in all_variables}

optimal_values = get_optimal_values(variables2_1, variables2_2)
print("Optimal Values:", optimal_values)
print("Total Cost:", problem.objective.value())

flight_3_members

variables3 = {
    flight_3_members[var]: LpVariable(
        flight_3_members[var],
        lowBound=0,
        cat='Integer'
    )
    for var in range(len(flight_3_members))
}

variables3

from pulp import LpMinimize, LpProblem, LpVariable, lpSum
# Define the problem
problem1 = LpProblem("Crew_Optimization2", LpMinimize)

# Define weights for objective function
alpha = 1     # Weight for cost minimization
beta = -0.1   # Weight to encourage maximizing crew utilization

problem1 += alpha*lpSum([salary_flight_3[i] * variables3[flight_3_members[i]] for i in set(range(len(flight_3_members)))]) + beta*lpSum(variables3.values())

for i, indices in enumerate(indices_2nd):
    selected_flight_3_members = first_second_third_selected.loc[indices, 'Flight_3_Allocated_Members']

    # Debugging print
    print(f"Index Group {i}: {indices}")
    print(f"Selected Flight 3 Members: {selected_flight_3_members.tolist()}")

    # Ensure all selected flights exist in either variables2 or variables4
    valid_variables = []
    missing_keys = []

    for flight in selected_flight_3_members:
        if flight in variables3:
            valid_variables.append(variables3[flight])
        else:
            missing_keys.append(flight)

    # Ensure Flight_1_Allocated_Members exist in optimal_values
    flight_2_key = first_second_third_selected['Flight_2_Allocated_Members'].iloc[i]
    if flight_2_key not in optimal_values:
        print(f"Warning: Key {flight_1_key} missing from optimal_values")
        continue  # Skip this constraint if optimal_values key is missing

    # Print missing variables for debugging
    if missing_keys:
        print(f"Warning: These flights are missing from both variables2 and variables4: {missing_keys}")

    # Only create constraint if valid variables exist
    if valid_variables:
        # problem1 += lpSum(valid_variables) == optimal_values[flight_2_key]
          problem1 += lpSum(valid_variables) >=1

problem1

# Filter out rows where 'NaN' is part of the 'Flight_3_Allocated_Members' value
df = pd.DataFrame(flight_3_members, columns=["Flight_3_Allocated_Members"])
df = df[~df["Flight_3_Allocated_Members"].str.contains("NaN", na=False)]

# Function to extract substring after "_"
def extract_after_underscore(value):
    if isinstance(value, str) and "_" in value:
        return value.split("_", 2)[1]  # Get part after "_"
    return None  # Return None if "_" is not found

# Extract the second part
df['extracted_part'] = df["Flight_3_Allocated_Members"].apply(extract_after_underscore)

# Drop duplicate extracted parts but keep first occurrence
df_unique = df[['extracted_part']].drop_duplicates().reset_index(drop=True)

# Get the indices where each extracted part appears (ensuring exact suffix matching)
df_unique['full_part_index'] = df_unique['extracted_part'].apply(
    lambda x: df.index[df['Flight_3_Allocated_Members'].apply(
        lambda y: y.endswith(x) if isinstance(y, str) else False
    )].tolist()
)

# Get the count of occurrences for each extracted part
df_unique['count'] = df_unique['full_part_index'].apply(len)

# Display the result
df_unique

# Merge on extracted_part (df_unique) and Members (flight1_details)
merged_df = df_unique.merge(flight1_details, left_on='extracted_part', right_on='Flight_1_Allocated_Members', how='left')

# Drop the 'Members' column and any other columns from flight1_details you don't want
merged_df = merged_df.drop(columns=['Flight_1_Allocated_Members', 'Total_salary'])

# Display the result
merged_df

from pulp import lpSum

for i, row in df_unique.iterrows():
    extracted_part = row['extracted_part']
    print(type(indices))
    if not indices:
        continue  # Skip if no matching indices

    # Extract selected flight members based on the indices
    selected_flight_3_members = first_second_third_selected.loc[indices, "Flight_3_Allocated_Members"]
    # Debugging print
    print(f"Index Group {i}: {indices}")
    print(f"Selected Flight 2 Members: {selected_flight_3_members.tolist()}")

    # Ensure all selected flights exist in either variables2_2 or variables2_1
    valid_variables = []
    missing_keys = []
    print(flight)
    for flight in selected_flight_3_members:
        if flight in variables3:
            valid_variables.append(variables3[flight].varValue)  # Use varValue as per your requirement
        else:
            missing_keys.append(flight)

# Assuming merged_df, df_unique, first_second_selected, and variables3 are already defined

max_limit = []
# Populate max_limit with the count values from merged_df
for i in merged_df['Flight_1_Max']:
    max_limit.append(i)

min_limit = []
# Populate min_limit with the count values from merged_df
for i in merged_df['Flight_1_Min']:
    min_limit.append(i)

# Loop over each row in df_unique to add constraints dynamically
for i, row in df_unique.iterrows():
    # Convert full_part_index from string to list of integers
    indices = row['full_part_index']
    if isinstance(indices, str):
        indices = list(map(int, indices.split(',')))

    # Extract selected flight members based on the indices
    selected_flight_3_members = first_second_third_selected.loc[indices, "Flight_3_Allocated_Members"].dropna()

    # Create a list to store valid variables
    valid_variables = []
    for flight in selected_flight_3_members:
        flight = flight.strip()  # Remove leading/trailing spaces
        # Check if the flight is in variables3 and add the corresponding LpVariable
        if flight in variables3:
            valid_variables.append(variables3[flight])  # Add the LpVariable from variables3

    # If there are valid variables, add constraints
    if valid_variables:
        # Ensure unique constraint names by using `i` to generate the name
        upper_constraint_name = f"Constraint_{i}_Upper_{hash(tuple(valid_variables))}"
        lower_constraint_name = f"Constraint_{i}_Lower_{hash(tuple(valid_variables))}"

        # Add the upper bound constraint
        problem1 += sum(valid_variables)  <= max_limit[i], upper_constraint_name

        # Add the lower bound constraint
        problem1 += sum(valid_variables) >= min_limit[i], lower_constraint_name

problem1

problem1.solve()
from pulp import LpStatus

print("Solver Status:", LpStatus[problem1.status])

336
35
2282927
2221
26222# Print the results
print("Optimal Solution:")
for var in variables3:
    print(f"{var}: {variables3[var].varValue}")
print("Total Cost:", problem1.objective.value())

# Combine all variables for easier handling
all_variables = set(variables2_1) | set(variables2_2)

# Check if the LP problem is feasible
# if problem.status != 1:  # status 1 means optimal
#     print("The LP problem is infeasible.")
#     # Print the lower bound of relevant variables
#     for var in all_variables:
#         if var in variables2_2:
#             print(f"{var}: {variables2_2[var].lowBound}")
#         elif var in variables2_1:
#             print(f"{var}: {variables2_1[var].lowBound}")
# else:
# Create a list to store the variable names and their optimal values
solution_data = []

# Store optimal values for all variables
for var in all_variables:
    if var in variables2_2:
        solution_data.append({'Variable': var, 'Optimal_Value': variables2_2[var].varValue})
    elif var in variables2_1:
        solution_data.append({'Variable': var, 'Optimal_Value': variables2_1[var].varValue})

# Also store values for variables3
for var in variables3:
    solution_data.append({'Variable': var, 'Optimal_Value': variables3[var].varValue})

# Create a DataFrame
solution_df = pd.DataFrame(solution_data)

# Display the DataFrame
print(solution_df)

print("Total_Cost:", problem1.objective.value() + problem.objective.value())

solution_df

final_df['Flight_1_Allocated_Members']

type(selected_flight_2_members)

